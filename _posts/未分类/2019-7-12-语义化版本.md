---
layout: post
title: 语义化版本
category: 未分类
---
# 关于版本的问题
## 问题1
某某软件新发布了一个版本2.2.2，这个版本号代表着什么意思？开发者想写个软件，版本号是从0.0.1开始呢还是从1.0.0开始？产品经理想发布一个软件的升级版本，是从1.0.4升级到1.0.5呢还是升级到1.1.0?

## 问题2
每个软件都可以定义自己版本号的规则，无可厚非，但是如果每个软件都定义自己的版本号规则，而这些规则又不一样，甚至互相冲突，那对用户来说版本号背后代表的含义就没有任何意义了。

## 问题3
版本兼容也是一个大问题，用户升级版本时经常要看一堆升级文档，其中描述了例如：
- 从x版本到y版本可以兼容升级
- 从y版本到z版本大部分兼容，除了xxx功能，需要xxx修改

然后确认自己是否能升级，试想一下你需要同时升级10个依赖的库，工作量该有多大

# 语义化版本
语义化版本控制规范就是为了来解决这些问题的，它是由Gravatars创办者兼GitHub共同创办者Tom Preston-Werner 所建立，主页https://semver.org/。

## 摘要
```
版本格式：主版本号.次版本号.修订号，版本号递增规则如下：

1. 主版本号：当你做了不兼容的 API 修改，
2. 次版本号：当你做了向下兼容的功能性新增，
3. 修订号：当你做了向下兼容的问题修正。
先行版本号及版本编译元数据可以加到“主版本号.次版本号.修订号”的后面，作为延伸。
```

## 语义化版本控制规范（SemVer）
```
以下关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、 RECOMMENDED、MAY、OPTIONAL 依照 RFC 2119 的叙述解读。（译注：为了保持语句顺畅， 以下文件遇到的关键词将依照整句语义进行翻译，在此先不进行个别翻译。）

1. 使用语义化版本控制的软件必须（MUST）定义公共 API。该 API 可以在代码中被定义或出现于严谨的文件内。无论何种形式都应该力求精确且完整。
2. 标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -> 1.10.0 -> 1.11.0。
3. 标记版本号的软件发行后，禁止（MUST NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行。
4. 主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。
5. 1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。
6. 修订号 Z（x.y.Z | x > 0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。
7. 次版本号 Y（x.Y.z | x > 0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。
8. 主版本号 X（X.y.z | X > 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。
9. 先行版本号可以（MAY）被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。
10. 版本编译元数据可以（MAY）被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译元数据可（SHOULD）被忽略。因此当两个版本只有在版本编译元数据有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。
11. 版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译元数据不在这份比较的列表中）。由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较，例如：1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。例如：1.0.0-alpha < 1.0.0。有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：只有数字的标识符以数值高低比较，有字母或连接号时则逐字以 ASCII 的排序来比较。数字的标识符比非数字的标识符优先层级低。若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。范例：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。
```

# 一个软件的版本号演变
## 0.1
第一个版本可以从0.0.1或者0.1.0开始，0.1.x的软件处于开发初始阶段，一切都可能随时被改变，这样的公共API不应该被视为稳定版。

## 1.0.0
当软件比较稳定后，就可以发布第一个正式版本1.0.0，这时发布的公共API后续就不能随意修改，需要兼容几个版本。

## 修订号
发现1.0.0有bug，没关系，直接在1.0.0基础上打patch，然后发布1.0.1，如果后续还有bug，就发布1.0.2

## 次版本号
1.0的功能比较有限，想再提供一些新的功能，这时需要发布1.1.0，次版本号更新说明有新功能，但是老功能兼容1.0.0

这时如果发现1.0.2和1.1.0上都有一个相同的bug，需要同时发布1.0.3和1.1.1

## 主版本号
发现1.0的某些功能设计的不好，想弃用，首先需要将这个公开API标记为弃用(java里面使用@Deprecated注解)，保持一段时间后（可能会保持几个次版本），最后在升级到2.0.0的时候可以把这些API删除。

版本越发越多后，需要维护的版本也会越来越多，会多到无法维护的地步，因此需要定义目前正在维护哪几个版本（太老的就不维护了），这主要取决于你的用户目前大部分升级到了哪个版本。

# 参考
- [语义化版本](https://semver.org/lang/zh-CN/)
