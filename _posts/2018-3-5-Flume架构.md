---
layout: post
title: Flume架构
---

Next you can update your site name, avatar and other options using the _config.yml file in the root of your repository (shown below).

![_config.yml]({{ site.baseurl }}/images/config.png)

The easiest way to make your first post is to edit this one. Go into /_posts/ and update the Hello World markdown file. For more instructions head over to the [Jekyll Now repository](https://github.com/barryclark/jekyll-now) on GitHub.

- 构建工具或者抽象，使得你周围人的工作可以产生乘法效应。例如，Jeff Dean创造了Protocal Buffers, Map Reduce, BigTable, Spanner以及其他系统级别的基础设施，增加了Google其他工程师的产出。因此Google专门为他创造了高级研究员的职位。
- 在软件或者设计方面积累足够的经验，可以给其他团队提供咨询，你的反馈非常有价值，可以让他们减少几天甚至几周的开发时间，或者你让一个快要失败的项目变成成功的项目。
- 成为一个专门领域的专家，并且这个领域是公司的基石。例如，你是一个机器学习的专家，然后在Facebook做news feed ranking，在Google做ads ranking，或者在Airbnb做search ranking的工作。你从事的项目可以直接为公司带来成长或效益。
- 你发现了一个很好的商业模式，也许是和其他销售和商业团队一起，成为核心团队的一员。
- 你负责培训新员工，培训其他工程师，使得他们对公司更有价值。
- 你在为公司构建一个完善的招聘流程中担任重要工作。
- 你在为公司创建品牌的过程中起到重要作用。


## 参考
- [The Secret to Growing Your Engineering Career If You Don't Want to Manage](http://www.theeffectiveengineer.com/blog/secret-to-growing-software-engineering-career?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

Flume NG是Cloudera提供的一个分布式、可靠、可用的系统，它能够将不同数据源的海量日志数据进行高效收集、聚合、移动，最后存储到一个中心化数据存储系统中。

本文试图还原Flume的设计者设计Flume架构的过程。

Flume的架构设计主要需要考虑：
1. 读取不同数据源
2. 写入不同数据库
3. 不丢数据
4. 支持水平扩展

## 单机版Flume
设计单机版的Flume需要考虑：
 1. 如何支持读取不同数据源的数据？
 2. 如何把数据写到不同的数据库？

于是可以抽象出以下几个概念：
- Source: 数据源可以抽象出一个Source接口，不同数据源只需要实现读取的逻辑，Source接口又可以分成两类：主动发送数据和被动读取数据。
- Event: Flume接收到数据以后，内部需要一个数据接口来表示数据，即：Event。
- Sink: 写数据同样需要抽象一个接口：Sink，不用数据库只需要实现写的逻辑。

整个Flume Agent的逻辑就是，不断读取Source，变成内部的Event，然后把Event写到Sink。

![](../../../images/flume/flume1.png)

## 如何解决生产者速度 > 消费者速度？
实现了简单的读取和写入的架构以后，接下来需要考虑一个实际问题：如何解决生产者速度 > 消费者速度的问题？当生产者速度 > 消费者速度时，生产者会被阻塞，这对日志收集系统是不能容忍的。

这个问题一个经典的解法就是在生产者和消费者之间加缓冲区：Channel。Agent中的Source线程负责读取数据并写到Channel，Sink线程负责从Channel中读取数据并写到外部数据库。

![](../../../images/flume/flume2.png)

## 单机版：如果保证不丢数据？

### 如何保证Source不丢数据？
Source是否能支持不丢数据，取决于接收数据的模式和Source的特性：

![](../../../images/flume/source.png)

### 如何保证Channel不丢数据？
1. Channel选择持久化存储（磁盘），Agent重启后Channel数据不会丢失
2. Channel满了，导致写入Channel失败 => 寄希望于Source有重试机制，否则会丢失数据
3. Agent所在机器挂了 => 保存在Channel中的数据丢失

### 如何保证Sink不丢数据？
Sink写数据在返回成功后再从Channel中删除数据。

### 如何保证Agent之间传递数据不丢数据？
Sink要在下游数据写到Channel后再从Channel中删数据，如果下游失败则回滚。

![](../../../images/flume/flume_transaction.png)

## 如何处理高并发？
要想让Flume支持高并发，前提是Source需要支持多个消费者访问。只需要部署多个Flume Agent，每个Agent读取数据源的某个部分，就可以轻松实现高并发。

![](../../../images/flume/flume3.png)

## 分布式版：Agent挂了，如果保证不丢数据？
当部署了多个Agent后，如果某个Agent所在机器挂了，Agent无法重启，就会导致该Agent负责的数据无法读取，导致数据丢失。

解决办法：同一个数据源被分配给多个Agent，当某个Agent无法工作时，其他的Agent会接手这部分数据的传输任务。

![](../../../images/flume/flume4.png)

## 如何控制Source的链接数？
假设数据源数量=n,每个Source会保存一个连接到数据源，即Source的连接数=n，当n变大后，Source无法同时保持很大的连接数。

解决办法：将Agent分组，某个组里面分配m个Agent，某个数据源只连接到某个分组，当n增大时可以通过增加分组数来减少连接数，当每个分组的Agent数量变少时，可以通过增加Agent来保持每个分组的Agent数量。

![](../../../images/flume/flume5.png)

## 如何控制Sink的链接数？
每个Agent Sink都会和数据库保持一个连接，当Agent变多时，连接数最终会超过数据库的限制。

解决办法：将Agent进行分层。

![](../../../images/flume/flume6.png)

## Reference
- [Architecture of Flume NG](https://blogs.apache.org/flume/entry/flume_ng_architecture)
- [Flume Github](https://github.com/apache/flume)
- [Flume Document](https://cwiki.apache.org/confluence/display/FLUME/Home;jsessionid=E7F7666DFE67BDEF020D03A64A845F62)
- [Flume Getting Started](https://cwiki.apache.org/confluence/display/FLUME/Getting+Started)
